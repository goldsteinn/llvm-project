; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=i686-unknown-unknown -mattr=-sse2 | FileCheck %s --check-prefix=X86
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=-sse2 | FileCheck %s --check-prefix=X64
; RUN: llc < %s -mtriple=i686-unknown-unknown -mattr=+sse2 | FileCheck %s --check-prefix=SSE2
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+sse2 | FileCheck %s --check-prefix=SSE2
; RUN: llc < %s -mtriple=i686-unknown-unknown -mattr=+avx2 | FileCheck %s --check-prefix=AVX2
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx2 | FileCheck %s --check-prefix=AVX2

define i32 @PR15215_bad(<4 x i32> %input) {
; X86-LABEL: PR15215_bad:
; X86:       # %bb.0: # %entry
; X86-NEXT:    movzbl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movzbl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movzbl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movb {{[0-9]+}}(%esp), %ah
; X86-NEXT:    shlb $3, %ah
; X86-NEXT:    andb $1, %cl
; X86-NEXT:    shlb $2, %cl
; X86-NEXT:    orb %ah, %cl
; X86-NEXT:    addb %dl, %dl
; X86-NEXT:    andb $1, %al
; X86-NEXT:    orb %dl, %al
; X86-NEXT:    andb $3, %al
; X86-NEXT:    orb %cl, %al
; X86-NEXT:    movzbl %al, %eax
; X86-NEXT:    andl $15, %eax
; X86-NEXT:    retl
;
; X64-LABEL: PR15215_bad:
; X64:       # %bb.0: # %entry
; X64-NEXT:    shlb $3, %cl
; X64-NEXT:    andb $1, %dl
; X64-NEXT:    shlb $2, %dl
; X64-NEXT:    orb %cl, %dl
; X64-NEXT:    addb %sil, %sil
; X64-NEXT:    andb $1, %dil
; X64-NEXT:    orb %sil, %dil
; X64-NEXT:    andb $3, %dil
; X64-NEXT:    orb %dl, %dil
; X64-NEXT:    movzbl %dil, %eax
; X64-NEXT:    andl $15, %eax
; X64-NEXT:    retq
;
; SSE2-LABEL: PR15215_bad:
; SSE2:       # %bb.0: # %entry
; SSE2-NEXT:    pslld $31, %xmm0
; SSE2-NEXT:    movmskps %xmm0, %eax
; SSE2-NEXT:    ret{{[l|q]}}
;
; AVX2-LABEL: PR15215_bad:
; AVX2:       # %bb.0: # %entry
; AVX2-NEXT:    vpslld $31, %xmm0, %xmm0
; AVX2-NEXT:    vmovmskps %xmm0, %eax
; AVX2-NEXT:    ret{{[l|q]}}
entry:
  %0 = trunc <4 x i32> %input to <4 x i1>
  %1 = bitcast <4 x i1> %0 to i4
  %2 = zext i4 %1 to i32
  ret i32 %2
}

define i32 @PR15215_good(<4 x i32> %input) {
; X86-LABEL: PR15215_good:
; X86:       # %bb.0: # %entry
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    andl $1, %eax
; X86-NEXT:    testb $1, {{[0-9]+}}(%esp)
; X86-NEXT:    jne .LBB1_1
; X86-NEXT:  # %bb.2: # %entry
; X86-NEXT:    testb $1, {{[0-9]+}}(%esp)
; X86-NEXT:    jne .LBB1_3
; X86-NEXT:  .LBB1_4: # %entry
; X86-NEXT:    testb $1, {{[0-9]+}}(%esp)
; X86-NEXT:    jne .LBB1_5
; X86-NEXT:  .LBB1_6: # %entry
; X86-NEXT:    retl
; X86-NEXT:  .LBB1_1:
; X86-NEXT:    orl $2, %eax
; X86-NEXT:    testb $1, {{[0-9]+}}(%esp)
; X86-NEXT:    je .LBB1_4
; X86-NEXT:  .LBB1_3:
; X86-NEXT:    orl $4, %eax
; X86-NEXT:    testb $1, {{[0-9]+}}(%esp)
; X86-NEXT:    je .LBB1_6
; X86-NEXT:  .LBB1_5:
; X86-NEXT:    orl $8, %eax
; X86-NEXT:    retl
;
; X64-LABEL: PR15215_good:
; X64:       # %bb.0: # %entry
; X64-NEXT:    # kill: def $edi killed $edi def $rdi
; X64-NEXT:    andl $1, %edi
; X64-NEXT:    leal 2(%rdi), %eax
; X64-NEXT:    testb $1, %sil
; X64-NEXT:    cmovel %edi, %eax
; X64-NEXT:    movl %eax, %esi
; X64-NEXT:    orl $4, %esi
; X64-NEXT:    testb $1, %dl
; X64-NEXT:    cmovel %eax, %esi
; X64-NEXT:    movl %esi, %eax
; X64-NEXT:    orl $8, %eax
; X64-NEXT:    testb $1, %cl
; X64-NEXT:    cmovel %esi, %eax
; X64-NEXT:    retq
entry:
  %0 = trunc <4 x i32> %input to <4 x i1>
  %1 = extractelement <4 x i1> %0, i32 0
  %e1 = select i1 %1, i32 1, i32 0
  %2 = extractelement <4 x i1> %0, i32 1
  %e2 = select i1 %2, i32 2, i32 0
  %3 = extractelement <4 x i1> %0, i32 2
  %e3 = select i1 %3, i32 4, i32 0
  %4 = extractelement <4 x i1> %0, i32 3
  %e4 = select i1 %4, i32 8, i32 0
  %5 = or i32 %e1, %e2
  %6 = or i32 %5, %e3
  %7 = or i32 %6, %e4
  ret i32 %7
}
